# [779. K-th Symbol in Grammar](https://leetcode.com/problems/k-th-symbol-in-grammar/description/?envType=daily-question&envId=2023-10-25)

## 題意

題目給 n 和 k，n 表示產生出的一個階層(1-index)，初始階層 1 為 0，每一個階層會把上一個階層中的 0 換成 01， 1 換成 10。
要求回傳階層 n 的排列中第 k 個(1-index)數字為多少。

## 想法

檢查一下測資，n 最多是 30，2^30 大概是 10 億，可以看得出是要方便 k 在 int 的範圍內(2^31-1)。  
這個級數的資料如果用暴力產出後遍歷，多半會超時，不然就是記憶體消耗過高(一個長度為 10 億的字串)。

通常這種時候就會列一下前幾個迭代找一下規律。

```
0
01
0110
01101001
```

可以發現規律從第 2 個階層後開始產生，第 1 個為 0，第 2 個為 1。
之後不管幾個階層，前半段都會和前一個階層完全一樣，而後半段則是**前半段的 0 - 1 顛倒**。
意思是 0110 中的後半 10，其實是 01 的反向，這個規律也能往下套到階層 3 和階層 4 的比較。

狀態會從上一階層繼承、明確基礎狀態對應答案，遞迴可以解決這個問題。
基礎狀態就是當 k <= 2，則 k 為 1 傳 0，k 為 2 傳 1。
利用上段推導的前半段後半段思維，檢查當前的 k 是在 n 的前半段還後半段。
如果是前半段，就減少 n 直到 k 在 n 的後半段。
如果是後半段，則 k 會是上一階層的第 k - 一半的位置的 1 - 0 反數。
這邊舉實例比較清楚，當 k = 3，n = 3，則實際上會等於 k = 2，n = 3 - 2(第三階層的一半) = 1，第二階層的第一個的 1 - 0 反數，因為第二階層該位置是 0，所以得到 k = 3，n = 3 的答案為 1。

## 程式

```
public class Solution {
    public int KthGrammar(int n, int k) {
        if(k <= 2){
            return k - 1;
        }
        var cover = Convert.ToInt32(Math.Pow(2, n - 1));
        if(k * 2 > cover){
            return KthGrammar(n - 1, k - cover/2) == 1 ? 0 : 1;
        }
        else{
            return KthGrammar(n - 1, k);
        }
    }
}
```
